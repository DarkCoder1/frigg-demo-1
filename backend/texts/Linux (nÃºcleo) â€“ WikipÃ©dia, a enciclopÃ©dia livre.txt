O núcleo do Linux (Linux Kernel) forma a estrutura base do sistema operacional/sistema operativo GNU/Linux, que é um sistema operacional tipo unix[6] . O núcleo do Linux é um dos exemplos mais proeminentes de software livre[7] , pois pode prover alicerce para o desenvolvimento e execução de outros softwares livres.
O núcleo Linux é distribuído sob a licença GNU General Public License versão 2 (GPLv2)[4] , sendo desenvolvido por colaboradores em todo o mundo. O desenvolvimento ocorre a partir da lista de e-mail do núcleo Linux (Linux kernel mailing list).
O Linux foi concebido pelo estudante do Departamento de Ciência da Computação da Universidade de Helsinki na Finlândia[8] , Linus Torvalds com ajuda de vários programadores voluntários por meio da Usenet (antecessora da Internet) em 1991.


Em março de 1991, Linus Torvalds, um estudante com 21 anos de idade na Universidade de Helsinki, Finlândia começava a trabalhar em algumas ideias simples para o desenvolvimento do núcleo de um sistema operacional (SO), como um projeto particular, inspirado pelo seu interesse no sistema operacional Minix, um pequeno sistema UNIX desenvolvido pelo professor Andrew S. Tanenbaum com fins educacionais [9] .
Os passos de desenvolvimento deste primeiro núcleo para um sistema operacional proposto por Linus Torvalds podem ser acompanhados pela lista de discussão comp.os.minix, cujas mensagens podem ser vistas em groups.google.com/group/comp.os.minix/topics (em inglês) . Torvalds começou com um alternador de contexto na linguagem de montagem do Intel 80386 e um controlador de terminal. Em 03 de junho de 1991 Torvalds tentou obter a especificação POSIX[10] , então em 26 de agosto de 1991, Torvalds postou a seguinte mensagem para comp.os.minix, um grupo de notícias na Usenet:
Eu estou fazendo um sistema operacional (livre) (apenas como passatempo, não vai ser grande e profissional como o GNU) para clones AT 386(486). Ele têm amadurecido desde Abril e está começando a ficar pronto. Eu gostaria de quaisquer comentários sobre coisas que as pessoas gostam/desgostam no minix, já que meu SO lembra um pouco o minix (mesma disposição física do sistema de arquivos (devido a razões práticas) entre outras coisas).
Eu já portei o bash (1.08) e o gcc (1.40), tudo parece estar funcionando. Isso significa que eu vou conseguir algo prático dentro de alguns meses e eu gostaria de saber que características as pessoas gostariam que houvesse. Todas sugestões são bem vindas, mas eu não prometo que serão incorporadas :-)
PS. Sim - ele é livre de qualquer código do minix e possui um sistema de arquivos com múltiplas linhas de execução (multi-threaded), ele NÃO é portável (usa troca de contexto do 386 etc) e provavelmente nunca vai suportar nada além dos discos rígidos AT, já que é tudo que eu possuo :-(. [11]
Depois da mensagem anterior a comunidade MINIX contribuiu com códigos e ideias para o Linux. Na verdade muitas pessoas contribuíram com o desenvolvimento de códigos para o projeto.
É valido lembrar que durante a idealização deste sistema operacional, proposto por Linus Torvalds, o mundo basicamente tinha como sistemas operacionais:
Na época, o Projeto GNU tinha criado muitos dos componentes exigidos para um sistema operacional livre, mas o seu próprio núcleo estava incompleto e indisponível. O sistema operacional BSD tinha problemas legais.Então devido a isto apesar da funcionalidade reduzida das primeiras versões, o Linux acumulou desenvolvedores e usuários rapidamente[12] ;.
Na data de setembro de 1991, a versão 0.01 do Linux foi lançada e enviada para o servidor FTP (ftp.funet.fi) da Universidade de Helsinki de Tecnologia (em inglês: HUT), possuía 10.239 linhas de código. Em setembro de 1991, a versão 0.02 do Linux foi lançada[13] .
Em dezembro de 1991, o Linux 0.11 foi lançado. Esta versão foi a primeira a ser auto-hospedada - O Linux 0.11 podia ser compilado por um computador executando Linux 0.11. Quando lançada a versão 0.12 em fevereiro de 1992, Torvalds adotou a licença GPL - GNU General Public License no lugar da licença anterior, escrita por ele mesmo e que não permitia redistribuição comercial[14] .
Um grupo de notícias conhecido como alt.os.linux foi criado e em 19 de janeiro de 1992, a primeira mensagem do alt.os.linux foi enviada[15] . Em 31 de Março de 1992 o alt.os.linux passou a comp.os.linux[16] .
O Sistema de Janelas X, que é um ambiente gráfico, logo foi portado para o Linux. Em março de 1992, a versão 0.95 do Linux foi a primeira a ser capaz de executar o sistema de janelas X. Este longo salto de número de versão, da 0.1x para 0.9x, foi devido a impressão de que uma versão 1.0, sem que nenhum recurso faltasse era iminente. No entanto, isto acabou provando-se um pouco superotimista e de 1993 até o começo de 1994, apareceram 15 versões em desenvolvimento da versão 0.99 do núcleo Linux.
Finalmente em 14 de março de 1994 é lançado o núcleo 1.0.0 do Linux, com 176.250 linhas de código. Em março de 1995, aparece o Linux 1.2.0 com 310.950 linhas de código.
A versão 2 do Linux, lançada em 09 de junho de 1996, foi sucedida por versões mais importante sob o cabeçalho da versão 2:
A versão 3 do Linux foi lançada em 22 de julho de 2011 em comemoração aos 20 anos do Linux, este núcleo foi lançado com 13.872.245 linhas de código. O núcleo do Linux a principio só mudava o primeiro número da versão em caso de mudanças drásticas, mas para comemorar os 20 anos do Linux e reduzir os números de controles de versão, Torvalds resolver mudar para a versão 3 mesmo sem mudanças significativas no núcleo do Linux. Em outubro de 2011 é lançada a versão 3.1 do núcleo Linux e em 05 de janeiro de 2012 é apresentada ao mundo a versão 3.2.1 do núcleo do Linux com 14.304.901 linhas de código [18] .
Inicialmente, Linus Torvalds distribuiu o Linux sob uma licença que proibia qualquer aproveitamento comercial. Entretanto, a partir da versão 0.12 do Linux, foi adotada uma licença GPL GNU General Public License, que permite a distribuição e venda de versões possivelmente alteradas ou não do Linux. Uma restrição da licença GPL é que esta exige que todas as cópias sejam distribuídas sob a mesma licença, em companhia do código fonte completo correspondente.
Torvalds descreveu o licenciamento sob a GPL como "a melhor coisa que eu já fiz".[19]
Atualmente, o Linux está licenciado sob a versão 2 da GPL[4] e diferentemente de muitos outros softwares, sob licença GPL, o Linux não tem nenhuma opção para utilizar versões mais recentes da GPL (diferente de muitos outros softwares GPLs). Existem muitas controvérsias sobre quão fácil é modificar a licença do Linux da GPLv2 para outra versão de GPL, tal como a GPL versão 3 e se isto é realmente desejável para o Linux[20] . O próprio Linus Torvalds indicou, até o lançamento da versão 2.4.0, que o seu código está somente sob a versão 2 da GPL[21] . Os termos GPL afirmam que se nenhuma versão é especificada, então qualquer versão pode ser utilizada. Segundo Alan Cox, pouquíssimos colaboradores Linux especificaram uma versão em particular da GPL[22] . Em julho de 2006, uma pesquisa com os 29 principais desenvolvedores do Linux, indicou que 28 preferiam a GPLv2 ao então atual rascunho da GPLv3. Torvalds comentou, "Eu acho que muitos forasteiros... acreditaram que eu era o único estranho no ninho, porque eu não me mostrava publicamente um fã da GPLv3"[23] . Desta forma, o núcleo Linux pode ser visto como sendo licenciado quase que exclusivamente pela GPLv2, já que o Linus Torvalds e grande parte dos desenvolvedores utilizam esta licença e não existem perspectivas destes utilizarem a versão 3.
É debatido se módulos carregáveis do núcleo (em inglês: LKMs) devem ser considerados Copyleft sob a lei de direito autoral dos Estados Unidos da América (EUA), pois desta maneira os módulos devem se enquadrar nos termos da GPL. Ou seja, se um módulo do núcleo Linux também deve assumir, por padrão, a mesma licença GPL utilizada pelo núcleo do Linux. Torvalds acredita que módulos que utilizem um subconjunto limitado e público das interfaces do núcleo Linux podem, algumas vezes, não ser trabalhos derivados, permitindo assim que alguns drivers binários e módulos não herdem a licença GPL do Linux. Entretanto, muitos colaboradores do Linux discordam desta interpretação, até Torvalds concorda que muitos módulos são trabalhos derivados, ele próprio escreveu: "módulos do núcleo SÃO derivados 'por padrão'". Mas em contrapartida, Torvalds também já disse que: "uma área indefinida em particular é algo como um controlador que foi originalmente escrito para outro sistema operacional (isto certamente não é um trabalho derivado originalmente do Linux). [...] ISTO é uma área indefinida e _esta_ é a área em que eu acredito que alguns módulos podem ser considerados como trabalhos não derivados, simplesmente por que eles não foram projetados para o Linux e não dependem de nenhum funcionamento específico dele."[24] Controladores gráficos proprietários, em particular, são amplamente discutidos. Enfim, é provável que tais questões só possam ser resolvidas em um tribunal.
Um ponto de controvérsia sobre o licenciamento é o uso que o Linux faz de "borrões binários" de firmware para suportar dispositivos de hardware. Estes arquivos são distribuídos sob grande variedade de licenças, muitas delas restritivas e seu código-fonte fundamental exato é desconhecido. Richard Stallman alega que estes "borrões" tornam o Linux parcialmente software de código fechado e que distribuir o Linux pode ser uma violação da GPL, que exige que "código-fonte completo correspondente" esteja disponível.[25] Em resposta, a FSFLA iniciou um projeto chamado Linux-libre, para criar um núcleo completamente livre sem objetos proprietários, o que é usado por algumas distribuições completamente livres [26] [27] . Em 15 de dezembro de 2010, o projeto Debian anunciou que a próxima versão estável do Debian utilizaria um núcleo livre de códigos proprietários[28] .
O Linux é uma marca registrada por Linus Torvalds nos Estados Unidos e em alguns outros países. Isto é resultado de um incidente no qual William Della Croce Jr, que não era envolvido no projeto Linux, registrou o nome Linux e depois pediu royalties pelo uso da marca Linux. Vários apoiadores do Linux integraram um conselho legal e entraram com uma ação contra Della Croce, que em 1998 concordou em repassar o registro da marca, para Linus Torvalds.
Para mais detalhes consulte en:SCO-Linux controversies Controvérsias SCO-Linux (em inglês).
Em março de 2003, o Grupo SCO (SCO) entrou com um processo contra a IBM reclamando que esta teria violado direitos autorais que o SCO disse possuir sobre o código fonte do Unix, ao contribuir com porções daquele código para o Linux. Além disso, o SCO enviou cartas para inúmeras companhias avisando que o seu uso do Linux sem uma licença do SCO poderia ser uma violação da lei de direitos autorais, e contou a impressa que eles iriam processar usuários individuais do Linux. A IBM então prometeu defender seus consumidores Linux em seu nome. Esta controvérsia gerou processos pelo SCO contra Novell, DaimlerChrysler (parcialmente indeferido em julho de 2004), e AutoZone, e processos retaliativos pela Red Hat e outras contra o SCO.
No começo de 2007 o SCO preencheu os detalhes específicos do objeto infringido. Não obstante às afirmações anteriores que o SCO era dono por direito de 1 milhão de linhas de código, ele especificou 326 linhas de código, a maioria das quais era inelegível para direitos autorais.[29] Em setembro de 2007, o tribunal no caso Novell decidiu que o SCO não era dono dos direitos autorais do Unix para começo de conversa,[30] embora a Corte de Apelações dos Estados Unidos para o Décimo Circuito decidiu em setembro de 2009 que a questão de quem era o dono propriamente dito dos direitos autorais ficava para o júri decidir.[31] O caso foi decidido em 30 de março de 2010, em favor da Novell.[32]
Em junho de 2009 a Microsoft "contribuiu" com 20.000 linhas de código para o Linux. A contribuição consistia de controladores (em inglês: drivers) do Hyper-V, que melhoravam a performance do Linux virtualizado no Windows 2008 Hyper-V ou Windows Server 2008 R2 Hyper-V. A Microsoft teve que licenciar seus controladores Hyper-V do Linux sob a GPL, quando o engenheiro chefe da Vyatta e o contribuidor Stephen Hemminger do Linux descobriram que a Microsoft havia incorporado controladores de rede do Hyper-V com componentes de código livre e ligado estaticamente a binários de código fechado (com copyright), o que é uma contravenção à licença GPL. Desta forma, a Microsoft contribuiu com os controladores para corrigir a violação da licença, embora a companhia tenha tentado descrevê-lo como um ato caridoso para evitar uma ação legal contra si [33] [34] [35] [36] .
O Linux suporta multitarefa de antecipação (em ambos modo usuário e modo núcleo), memória virtual, bibliotecas compartilhadas, carregamento por demanda, executáveis de cópia-ao-escrever compartilhados, gerenciamento de memória, o conjunto de protocolos de Internet, e execução em linhas.
O Linux é um núcleo monolítico. Os controladores de dispositivos e as extensões de núcleo são executadas no espaço de núcleo (anel 0 em muitas arquiteturas de CPU), com acesso completo ao hardware, embora algumas exceções sejam executadas no espaço de usuário. O sistema gráfico, que é o ambiente gráfico mais utilizado no Linux, não é executado no núcleo, em contraste com o encontrado no Microsoft Windows.
Preemptividade do modo de núcleo permite que controladores de dispositivos sejam antecipados sob certas condições. Este recurso foi adicionado para aperfeiçoar o tratamento de interrupções de hardware e melhorar o suporte para multiprocessamento simétrico (em inglês: SMP). Preemptividade também otimiza a latência, aumentando a responsividade e tornando o Linux mais apropriado para aplicações de tempo real.
O fato do Linux ser um núcleo monolítico mais do que um micronúcleo foi o tópico do debate entre Andrew S. Tanenbaum e Linus Torvalds.[37] O debate iniciou em 1992, sobre Linux e arquiteturas de núcleo em geral no grupo de discussão comp.os.minix na Usenet.[38] Tanenbaum argumentou que micronúcleos são superiores a núcleos monolíticos, e portanto, o Linux era obsoleto. Diferentemente de núcleos monolíticos tradicionais, controladores de dispositivos são configurados facilmente como módulos carregáveis, e são carregados ou descarregados durante a execução do sistema. Este assunto foi revisitado em 09 de maio de 2006,[39] e em 12 de maio de 2006 Tanenbaum escreveu uma declaração.[40]
O Linux é escrito na versão da linguagem de programação C suportada pelo GCC, que introduziu inúmeras extensões e mudanças ao C padrão, aliado a várias seções de código menores escritas na linguagem de montagem, na sintaxe e estilos do GCC e "AT&T", da arquitetura alvo. Devido às extensões suportadas pela linguagem C, o GCC foi por um longo período o único compilador capaz de compilar o Linux corretamente. Em 2004, a Intel disse ter modificado o Linux para que seu compilador C também pudesse compilá-lo.[41] Outro sucesso foi apresentado em 2009, com um 2.6,22 modificado.[42] [43]
Muitas outras linguagens foram usadas de algum modo, essencialmente em conexão com o processo de compilação, os métodos pelos quais as imagens inicializáveis são criadas através do código fonte. Estas incluem Perl, Python, e várias linguagens shell script. Alguns controladores podem até ser escritos em C++, Fortran, ou outras linguagens, mas isto é extremamente desencorajado. O sistema de compilação do Linux oficialmente suporta apenas o GCC, como um compilador de núcleo e controladores.
O Linux não seria projetado para ser portável em seu projeto inicial, a principio ele só seria executado em arquiteturas x386. Entretanto com a ajuda da comunidade, atualmente o núcleo do Linux pode ser executado em uma gama extremamente grande de arquiteturas, indo desde um computador de mão iPAQ a um servidor mainframe System z9 da IBM, que é capaz de executar centenas e até milhares de instâncias do Linux simultâneas.
O Linux é o principal sistema operacional dos supercomputadores da Blue Gene da IBM. Desde junho de 2009, o Linux é usado como núcleo em mais de 88% dos sistemas na lista Top 500 de supercomputadores.[44]
O Linux hoje funciona em dezenas de plataformas, desde mainframes até um relógio de pulso, e várias arquiteturas: x86 (Intel, AMD), x86-64 (Intel EM64T, AMD64), ARM, PowerPC, Alpha, SPARC etc., com grande penetração também em sistemas embarcados, como handhelds, PVR, vídeo-jogos e centros multimídia, entre outros. O Linux possui suporte para muitas arquiteturas de máquinas virtuais.
Além disso, o Linux foi portado para vários dispositivos móveis como o TuxPhone e o iPod da Apple. Sistemas operacionais como o Google Android, o MeeGo (fusão entre o Nokia Maemo e o Intel Moblin), desenvolvidos para dispositivos móveis, utilizam versões modificadas do Linux.[45] [46] [47] .
Um processo é uma instância de um programa em execução[48] . Todo processo no Linux tem um pai (processo criador) e um número identificador (PID - Process Identity). O pai de todos os processos em um ambiente Linux é o init, cujo PID é 1. Este processo é criado pelo processo 0, que é um encadeamento (thread) do próprio núcleo. O processo init irá permanecer em execução até o desligamento do sistema e sua função é monitorar e criar os processos que implementam as camadas exteriores do sistema operacional.
Os processos são criados pela chamadas de sistema fork() (processos tradicionais ou heavy weight) e clone() (processos leves ou light weight). Para otimizar a criação de processos tradicionais, o Linux usa o recurso de copy-on-write: quando um processo filho é criado, ele compartilha as mesmas páginas de memória do pai. Quando um dos dois tenta escrever na memória, é gerada uma interrupção para o núcleo, que então copia o conteúdo das páginas de memória para novas molduras de páginas e estas são atribuídas ao processo que efetuou a escrita.
Para manter um ambiente multitarefa e possibilitar o multiprocessamento, o Linux mantém algumas estruturas importantes, das quais podemos citar duas: (i) o descritor do processo (task_struct), que contém todas as informações relativas ao processo; (ii) uma fila (runqueue) de processos por processador. Quando o sistema possui mais de um processador, o agendador do Linux faz o balanceamento de carga entre as filas.
Para um compartilhamento justo, do processador entre os processos, o Linux usa duas classificações para avaliar qual a prioridade de um processo, sendo estas: (i) determina a responsividade do processo (tempo real, interativo, em segundo plano); (ii) verifica se o processo usa muito tempo de processador (CPU-bound) ou faz muitas operações de entrada e saída (I/O-bound).
Essas duas classes são razoavelmente independentes. Um processo pode executar em segundo plano (um daemon, por exemplo) e ser consumidor de recursos de entrada e saída (um servidor de banco de dados, por exemplo) ou usar muito tempo de processador (tal como, um compilador). Um processo que executa operações em tempo real foi assim definido pelo seu programador, mas o agendador do Linux necessita fazer uma análise heurística para saber se um processo é interativo ou está executando em segundo plano.
O Linux utiliza um sistema de prioridades, no qual um processo que possui prioridade maior tem precedência sobre um de prioridade menor, para obter o processador. A identificação da prioridade de um processo pode ser estática ou dinâmica e varia de 1, a maior prioridade, a 139, a menor. Os números 1 a 99 são atribuídos a processos de tempo real e 100 a 139 são atribuídos a processos tradicionais (interativos e segundo plano).
Um processo é classificado em "primeiro a entrar, primeiro a sair" (em inglês: firtst-in, first-out FIFO) ou "todos contra todos" (em inglês: Round-Robin RR) e somente será retirado do processador nos seguintes casos: (i) fim de execução; (ii) para ser substituído por um processo de maior prioridade; (iii) executar uma operação de bloqueio; (iv) espontaneamente; (v) é RR e esgotou seu quantum de processamento.
Um processo tradicional tem inicialmente atribuída uma prioridade estática (em geral 120) que determina o seu quantum de processamento, mas pode ter uma prioridade dinâmica, que é o valor analisado pelo agendador quando percorrer a lista de processos para determinar qual irá usar o processador. A prioridade dinâmica pode alterar o valor da prioridade estática em 5 pontos, para mais (penalidade) ou para menos (bônus), dependendo do passado do processo. O passado irá beneficiar o processo se o mesmo ficou muito tempo fora do processador (sleep time). Caso este tempo seja pequeno, o processo será penalizado.
A estrutura anterior pode ser modificada a partir do lançamento do núcleo 2.6.23 ou posterior, com a introdução do "escalonador completamente justo" (em inglês: completely fair scheduler CFS).
O Linux utiliza memória virtual, que possui, pelo menos, 4 funções básicas:
Seu código divide-se em duas partes. Uma é dependente da arquitetura, onde são definidos o endereçamento — virtual e físico, o tamanho de página e o tratamento das tabelas de páginas. Na parte independente ficam o controle de alocação e liberação de memória e o esquema de substituição páginas.
O Linux utiliza tamanhos de páginas de acordo com a arquitetura. Os processadores x86 utilizam páginas de 4 KiB (padrão), 2 MiB (caso seja utilizado o recurso de Extensão de Endereço de Página (em inglês: Page Address Extension PAE) – da Intel) ou de 4 MiB. Nas arquiteturas RISC o tamanho padrão é de 8 KiB, mas não é o único.
O endereçamento virtual é dividido em espaço do usuário e espaço do núcleo. O primeiro é privativo de cada processo, com início no endereço lógico zero e terminando no endereço determinado pela macro PAGE_OFFSET . O espaço do núcleo é único e começa depois do espaço do usuário. Na arquitetura x86 PAGE_OFFSET determina um valor de 3 GiB para o espaço do usuário e 1 GiB para o espaço do núcleo.
O código do Linux é carregado no início do espaço do núcleo, sendo seguido pela área fisicamente mapeável (mem_map, estrutura que indexa as páginas físicas e as páginas propriamente ditas). Na arquitetura x86, os últimos 128 MiB do espaço do núcleo são reservados para alocação de memória não contígua e memória alta, limitando a memória física endereçável pelo Linux, na compilação padrão, a 896 MiB.
Um endereço virtual no Linux , é dividido em 5 campos: diretório de páginas (PGD), diretório superior de páginas (PUD), diretório intermediário de páginas (PMD), tabela de páginas (PTE) e deslocamento (offset). A arquitetura x86 possui um espaço de endereçamento de 32 bits; quando são utilizadas páginas de 4 KiB (o padrão) o PUD e o PMD não são utilizados; o PGD e o PTE usam 10 bits cada, e o deslocamento usa 12 bits.
O esquema de substituição de páginas no Linux usa o algoritmo LRU (por aproximação) mantendo duas listas de envelhecimento (em inglês: aging). A primeira (active_list) contém as páginas atualmente em uso (as páginas mais recentemente referenciadas estarão mais próximas do início da lista) e a segunda (inactive_list) contém as candidatas a paginação (em inglês: page out).
A paginação para disco pode ocorrer sob demanda, quando algum processo solicitar página e não houver alguma disponível. Neste caso, a página no final da lista inactive_list é liberada. Entretanto, existe um processo chamado kswapd, inicializado pelo núcleo, que verifica, periodicamente, o número de páginas livres. Caso este número seja menor que pages_low, kswapd é acordado para liberar páginas. Se o valor chegar a pages_min, kswapd entra num regime síncrono para agilizar a liberação. Quando o valor de páginas livres atingir pages_high, kswapd vai dormir.
O gerenciamento de arquivos no Linux baseia-se num esquema de vários níveis, onde a camada principal é o VFS (Virtual File System), que esconde da aplicação as características dos diversos sistemas de arquivo reconhecidos pelo Linux. Quando uma aplicação solicita uma operação sobre algum arquivo, essa solicitação é encaminhada para o VFS, que reenvia a solicitação para um dos SA registrados.
O VFS utiliza uma estrutura chamada superbloco para manter as informações referentes aos diversos sistemas de arquivos montados (tipo, ponto de montagem, dispositivo de bloco utilizado, arquivos abertos). Também utiliza index-node ou nós-i, semelhantes aos nós-i do Ext2, com as informações sobre os arquivos (permissões, blocos utilizados, dono, etc.).
Os sistemas de arquivos registrados no VFS podem ser classificados em 3 grupos: (i) dispositivos de blocos (Ext2, Ext3, Ext4, Reiserfs, XFS, VFAT); (ii) associados a rede (NFS, SMB); (iii) dispositivos especiais (procfs, tempfs). Todos esses sistemas podem ser carregados como módulos.
O Ext2 está deixando de ser o padrão de sistema de arquivos utilizado no Linux, particularmente por sua deficiência quando ocorre uma pane. Neste caso, o sistema operacional deve executar uma varredura completa para verificar o estado do sistema (fsck). Outros sistemas foram criados para resolver essa deficiência, utilizando um recurso chamado journaling, que é a utilização de um registro (log) de alterações (journal). Os sistemas de arquivos desse tipo mais importantes são: Ext3, Ext4, Reiserfs, XFS e JFS.
Uma pane do núcleo (em inglês: kernel panic) é um erro de sistema não-recuperável detectado pelo núcleo, ao contrário de erros gerados em espaço de usuário, como por exemplo, o fechamento inesperado de um aplicativo. O código do núcleo pode indicar essa condição invocando a função panic especificada em sys/system.h. No entanto, grande parte das panes são geradas a partir de exceções do processador não-tratadas no código do núcleo, tal como referências inválidas a posições de memória. Geralmente, a ocorrência de uma pane do núcleo indica um defeito na cadeia de chamadas na inicialização do núcleo. Também pode indicar uma falha de hardware, tais como uma falha em uma célula de memória, erros nas funções aritméticas ou superaquecimento do processador.
Um relatório de falha no núcleo é chamado de "OOPS" [50] . O relatório é automaticamente coletado pelo software kerneloops [51] ou pela extensão kernel oops do abrt [52] e enviado ao kerneloops.org. O Kerneloops.org reúne estes relatórios e publica estatísticas em seu sítio[53] .
O custo para criar o Linux novamente, em sua versão 2.6.0, em uma configuração tradicional de desenvolvimento proprietária foi estimada em cerca de $612 milhões USD (€467 milhões de euros, 1,145 bilhão de Reais), com base nos custos de 2004, utilizando o modelo COCOMO de estimativa pessoa-mês.[54] Em 2006, um estudo financiado pela União Europeia colocou os custos de redesenvolvimento do núcleo 2.6.8 ainda mais altos, €882 milhões ($1,14 bilhões USD).[55]
Este assunto foi revisitado em setembro de 2008 por Amanda McPherson, Brian Proffitt e Ron Hale-Evans. Usando a metodologia de David A. Wheelers, eles estimaram que refazer o núcleo 2.6.25 teria custos de $1.3 bilhão USD (parte de um total de $10.8 bilhões para refazer todo o Fedora 9).[56] Novamente, Garcia-Garcia e Alonso de Magdaleno, da Universidade de Oviedo (Espanha), estimaram que o valor adicionado anualmente ao núcleo entre 2005 e 2007 foi de 100 milhões de euros e, em 2008, 225 milhões de euros; custaria também mais que 1 bilhão de euros (aproximadamente 1.4 bilhões USD) para desenvolvê-lo na União Europeia.[57]
A versão 1.0 do Linux foi lançada em 14 de março de 1994[58] . Este lançamento só suportava sistemas de computador monoprocessados baseados na i386. A portabilidade se tornou uma preocupação e logo, na versão 1.2, lançada em 07 de março de 1995[59] , ganhou suporte as arquiteturas Alpha, SPARC, e MIPS.
A versão 2.0 foi lançada em 09 de junho de 1996[60] . Já haviam sido 41 lançamentos em série. O principal recurso da 2.0 foi o suporte a multiprocessamento simétrico, ou seja, suporte para múltiplos processadores em um único sistema e suporte, também foi incluído suporte para mais arquiteturas de processadores.
A versão 2.2 foi lançada em 26 de janeiro de 1999[61] , que removeu o spinlock global e forneceu suporte melhorado para multiprocessadores, também adicionou suporte para as arquiteturas m68k e PowerPC, assim como a novos sistemas de arquivos, incluindo suporte somente de leitura para o NTFS da Microsoft[62] .
A versão 2.4.0, lançada em 04 de janeiro de 2001[63] , continha suporte para Ligar e Usar ISA, USB, e PC Cards[64] . Ele também incluía suporte ao processador PA-RISC da Hewlett-Packard. Também foram incluídos suporte a Bluetooth, [[Logical Volume Manager (Linux)|Gerenciador Lógico de Volumes (em inglês: LVM)]] versão 1, suporte RAID, InterMezzo e sistemas de ficheiro ext3.
A versão 2.6.0 foi lançada em 18 de dezembro de 2003[65] . A série de núcleos 2.6 ainda ativa ( em fevereiro de 2012). O desenvolvimento para o 2.6.x se modificou mais ao incluir novos recursos através da duração da série. Entre as mudanças que foram realizadas, estão: integração do µClinux no código-fonte principal do Linux, suporte a extensão de endereço físico (em inglês: PAE), suporte a diversas linhas novas de CPUs, integração da Arquitetura de Som Avançada do Linux (em inglês: ALSA) no código principal do Linux, suporte para até 232 usuários (acima de 216), suporte para até 229 IDs de processo (acima de 215), aumentou substancialmente o número de tipos de dispositivo e número de dispositivos para cada tipo, aperfeiçoou o suporte 64-bits, suporte para sistema de ficheiros de até 16 terabytes, preemptividade no núcleo, suporte para a biblioteca de linhas de execução nativa do POSIX, integração do linux em modo de usuário ao código principal do Linux, integração do SELinux ao código principal do Linux, suporte à Infiniband, e muito mais. Em destaque estão as adições de vários sistemas de arquivos através dos lançamentos 2.6.x: FUSE, JFS, XFS, ext4 e mais. Detalhes da história da série de núcleos 2.6 podem ser encontradas em registros da mudança (em inglês: changelog) na área de lançamentos dos núcleos 2.6 do sítio kernel.org.
A versão 3.0 foi lançada em 22 de julho de 2011, não houve grandes mudanças no núcleo[66] (como normalmente se espera quando muda o primeiro número da versão). A versão 3.0 foi dada em comemoração aos 20 anos do Linux. A partir desta versão foi alterada a forma de interpretação dos números de versionamento do núcleo Linux[66] .
A organização do código fonte do núcleo do Linux permite que múltiplos desenvolvedores trabalhem no núcleo simultaneamente sem causar conflitos com outros desenvolvedores. O diretório raiz do código fonte da versão 3.2.2 possui 8 arquivos e 21 diretórios. Os arquivos são basicamente descrição de licença, créditos, informações sobre o núcleo e arquivos para compilação. Os diretórios estão estruturados de forma a tornar independente as implementações de código dependente e independente de arquitetura. Além disso, estão organizados baseados nos principais subsistemas do núcleo Linux [67] .
Os principais arquivos são [18] :
Os principais diretórios são[18] :
O processo de inicialização do núcleo do Linux é composto por diversas etapas[68] . Antes da inicialização propriamente dita, o sistema computacional deve ser inicializado. O sistema possui um software embarcado em uma posição fixa de memória para iniciar o carregamento do núcleo. Em sistemas convencionais, o processo de inicialização ocorre com o carregamento da BIOS e inicialização do hardware. A BIOS, por sua vez, realiza a leitura do primeiro setor do disco (MBR) contendo o carregador de inicialização (bootloader). Os carregadores de inicialização mais comuns para computadores pessoais são o GRUB e LILO. O carregador de inicialização carrega a imagem do núcleo do Linux e do sistema de arquivos temporário em memória (opcional). O arquivo de imagem do núcleo Linux é autocompactado e geralmente apresenta a nomenclatura bzImage-versão. O arquivo de disco RAM, que contém o sistema de arquivos temporário, geralmente apresenta a nomenclatura initrd-versão.img.
Com o núcleo em memória, o controle de execução é repassado para o núcleo. A inicialização do núcleo começa com a execução de rotinas básicas de configuração de hardware e a autodescompactação da imagem por meio de rotinas no início do arquivo. Em seguida, a função start_kernel é chamada e executa a inicialização e configuração dos dispositivos, escalonadores, consoles, entre outros. Por fim, após carregar o disco RAM, executa a função que inicializa o primeiro processo, o init. O init coordena a inicialização e configuração dos serviços do sistema operacional. Em sistemas embarcados, o init pode corresponder a um simples código para iniciar os dispositivos.
Ref:www.kernel.org[69]
O modelo de desenvolvimento atual do Linux é feito para permitir que Linus Torvalds realize o lançamento de novas versões constantemente. Estas versões são chamadas de núcleos "genérico" (em inglês: vanilla) ou "principais" (em inglês: mainline), que significa que estes núcleos são derivados (branch) do código de desenvolvimento principal do núcleo Linux. Uma nova versão do núcleo Linux só é lançada depois de passar por grandes mudanças, por exemplo, primeiro Linus Torvalds recebe e incorpora dos programadores as mudanças no código do núcleo Linux, a partir dai são feitos pré-lançamentos do núcleo e destes são realizadas as correções de possíveis defeitos encontrados, só então é lançada a nova versão do núcleo do sistema operacional Linux. O lançamento de um novo núcleo é feito em média a cada três meses.
No esquema de desenvolvimento atual, a derivação (branch) principal não é a versão "estável" tradicional, pois é ela que incorpora todos os tipos de alterações, tal como últimos recursos, correções de segurança e defeitos. Para usuários que não querem arriscar atualizando para novas versões, contendo código que pode não ter sido testado o bastante, existem um conjunto separado de derivações "estáveis" (uma para cada versão lançada), que são criadas para usuários que querem apenas as correções de segurança e defeitos, mas não uma versão totalmente nova. Estas derivações são mantidas pelo time estável (em inglês: stable team) (Greg Kroah-Hartman, Chris Wright, talvez outros).
A maioria dos usuários Linux utilizam a versão fornecida pelas suas distribuições. Algumas distribuições fornecem os núcleos "genérico" e/ou "estável". No entanto, muitos distribuidores Linux, como a Red Hat e o Debian, mantém outro conjunto de derivações do Linux que são integradas aos seus produtos. Estes são em geral atualizados em um ritmo mais lento em comparação com a derivação "genérico" e normalmente incluem todas correções da derivação "estável" correspondente, mas ao mesmo tempo podem adicionar suporte a controladores ou recursos que não foram lançados na versão "genérico" em que o distribuidor se baseou originalmente.
A partir do núcleo 2.6 ocorreu uma mudança significativa no modelo de desenvolvimento. Antes desta alteração havia uma derivação estável, por exemplo, a 2.4 em que apenas revisões relativamente pequenas e seguras eram feitas e uma derivação instável a 2.5, na qual mudanças maiores e retiradas de códigos não utilizados eram permitidas. Ambas derivações eram mantidas pelo mesmo grupo de pessoas, lideradas por Torvalds. Isto significada que os usuários sempre teriam uma versão 2.4 bem testada (chamada de estável), contendo as últimas correções de segurança e praticamente sem defeitos, porém esta estabilidade tinha um preço, pois os usuários do núcleo estável sempre estavam um passo a trás, ou seja, estavam desatualizados em relação ao núcleo instável (por exemplo, poderia não ter suporte aos hardwares mais recentes). No fim da série 2.5.x, alguns mantenedores escolheram tentar portar suas alterações para a série de núcleos estáveis, o que resultou em defeitos sendo introduzidos nos núcleos 2.4.x. A derivação 2.5 foi então oficialmente declarada estável, e renomeada para 2.6, mas ao invés de abrir uma derivação instável 2.7, os desenvolvedores escolheram continuar a fazer grandes revisões na derivação 2.6, permitindo lançamentos muito mais rápidos do que a 2.4.x, mas ainda sim, mais lentos do que a 2.5.x. Isto trouxe o efeito desejado de tornar novos recursos rapidamente disponíveis e conseguir mais testes do novo código, que foi adicionado em derivações menores e mais fáceis de testar.
Como resposta a falta de uma árvore de núcleo estável, algumas pessoas coordenaram a coleta de correções e em dezembro de 2005 Adrian Bunk anunciou que ele manteria os lançamentos dos núcleos 2.6.16.y, mesmo quando o time continuasse para o 2.6.17[70] . Ele também incluiu alguns atualizações de controladores, tornando a manutenção da série de núcleos 2.6,16 muito similar às antigas regras de manutenção para uma série estável, como a 2.4[71] . Deste então, o "time estável" (em inglês: stable team) foi criado e poderia continuar atualizando as versões do núcleo com correões. Em setembro de 2008, Adrian Bunk anunciou que iria manter o 2.6.27 por alguns anos como substituto ao 2.6.16[72] . O time estável apoiou a ideia[73] e a de 2010[update] eles mantêm aquela versão, lançando correções para ela, além das outras.
Após a mudança no modelo de desenvolvimento no núcleo 2.6.x, os desenvolvedores continuaram querendo o que pode-se chamar de uma árvore instável do núcleo, uma que muda tão rapidamente quanto novas correções chegam. Andrew Morton decidiu redirecionar sua árvore -mm de gerenciamento de memória, para servir como destino para todo código novo e ou experimental. Em setembro de 2007 Morton decidiu parar de manter a sua árvore[74] . Em fevereiro de 2008, Stephen Rothwell criou a árvore linux-next (em português: próximo-linux) em que correções que almejam serem incorporadas durante o próximo ciclo de desenvolvimento[75] [76] . Vários mantenedores de subsistemas também adotaram o sufixo -next (em português: próximo(a)) para suas árvores contendo código a ser enviado para inclusão no próximo ciclo de lançamento.
Enquanto que Linus Torvalds supervisa as alterações no código e os lançamentos para as últimas versões do núcleo, ele delegou a manutenção das versões anteriores para outros programadores. Lançamentos importantes tão antigos quanto o 2.0, oficialmente obsoleto com o lançamento do 2.2.0 em janeiro de 1999, são mantidos conforme a necessidade, embora a uma velocidade muito lenta.
Outros programadores do Linux que mantêm subsistemas dentro do núcleo[92] incluem:
O código do Linux costumava ser mantido sem ajuda de um sistema de controle de versão, principalmente devido ao desgosto de Linus Torvalds com relação a sistemas centralizados.
Em 2002, o desenvolvimento do Linux mudou para o BitKeeper, um sistema de controle de versões que satisfazia os requerimentos técnicos de Linus Torvalds. BitKeeper foi disponibilizado para Linus e outros gratuitamente, mas não era software livre, o que criou controvérsias. O sistema não oferecia interoperabilidade alguma com sistemas livres como CVS e Subversion.
Em abril de 2005, no entanto, esforços para realizar a engenharia-reversa do sistema BitKeeper por Andrew Tridgell levou BitMover, a empresa que mantinha o BitKeeper, a parar de suportar a comunidade de desenvolvimento Linux. Em resposta, Linus Torvalds e outros, escreveram um novo sistema de controle de versões para a tarefa, chamado Git. O novo sistema foi criado em semanas e em dois meses o primeiro lançamento oficial do núcleo foi realizado utilizando o git[93] . O git logo se tornou um projeto independente do núcleo Linux e foi largamente adotado como sistema de controle de versão/revisão da comunidade de software livre.
O núcleo Linux já passou por três esquemas de numeração de versões.
A primeira versão do núcleo foi 0.01. Esta foi sucedida por 0.02, 0.03, 0.10, 0.11, 0.12 (a primeira versão sob GPL), 0.95, 0.96, 0.97, 0.98, 0.99 e então 1.0[94] . A partir da 0.95 houve vários lançamentos de correções entre as versões.
Após o lançamento da versão 1.0 e até o lançamento da 2.6, as versões eram compostas de "A.B.C", na qual A era definido como a versão do núcleo, B como a grande revisão do núcleo e C a revisão menor do núcleo. A versão era alterada somente quando ocorriam grandes alterações no código e/ou no conceito do núcleo, isto aconteceu duas vezes na história do núcleo: em 1994 (versão 1.0) e em 1996 (versão 2.0). As grandes revisões foram usadas de acordo com o sistema de numeração par-ímpar tradicional. A revisão menor foi alterada quando correções de segurança, defeitos ou novos recursos eram implementados no núcleo. Em 2011 foi lançada a versão 3.0 do núcleo Linux, apesar da versão mudar da 2.x para a 3.x nenhuma grande mudança ocorreu no núcleo, a mudança se deu em comemoração ao vigésimo aniversário do Linux [95] . Na versão 3.x o esquema de numeração continua basicamente o mesmo da versão introduzida a partir do núcleo 2.6.0, mas utilizando o segundo número, por exemplo a versão 3.1 surge poucos meses depois da 3.0. O terceiro número agora é adicionado quando for necessário indicar correções de segurança e correções de erros, por exemplo 3.0.18.
Desde 2004, após o lançamento da versão 2.6.0, os desenvolvedores do núcleo discutiram sobre o esquema de lançamento e versões[96] [97] e por fim, Linus Torvalds e outros decidiram que um ciclo de lançamentos menor seria melhor. Desde então, a versão foi composta de três ou quatro números. Os primeiros dois se tornaram bastante irrelevantes, sendo o terceiro número a versão atual do núcleo e o quarto número conta apenas com atualizações para correções de segurança e defeitos.
O primeiro uso do quarto número ocorreu quando um grave erro, que exigia correção imediata, foi encontrado no código do NFS da 2.6.8. No entanto, não havia outras alterações para legitimar o lançamento de uma nova revisão menor (que teria sido a 2.6.9). Então, a 2.6.8.1 foi lançada, com apenas uma alteração sendo feita para corrigir o defeito. Com a 2.6.11, esta foi adotada como a nova política oficial para versões. Depois, se tornou comum portar grandes correções para versões já lançadas e indicar isto atualizando o quarto número.
Pré-lançamentos regulares de desenvolvimento são nomeados candidatos a lançamento, o que é indicado adicionando o sufixo rc a versão do núcleo, seguido por um número ordinal.
Alguma vezes também, a versão vai possuir um sufixo como tip, indicando outra derivação de desenvolvimento, geralmente, mas não sempre, são adicionadas as iniciais da pessoa que o criou. Por exemplo, ck significa Con Kolivas, ac Alan Cox, etc. Algumas vezes, as letras são relacionadas à área de desenvolvimento principal do ramal do qual o núcleo é compilado, exemplo wl indica uma compilação de teste de rede sem fio (em inglês: WireLess). Além disso, distribuições GNU/Linux podem criar seus próprios sufixos, com diferente sistemas de numeração, e para transportes de correções para suas versões de distribuição "Empresariais" (ex. estável, mas mais antigo).
Torvalds e sua equipe têm continuado a lançar novas versões, consolidando contribuições de outros programadores e introduzindo alterações suas. Antes do lançamento da versão 2.6, o número de versão menor (o segundo componente) par indicavam uma série estável: 1.0.x, 1.2.x, 2.0.x, 2.2.x e 2.4.x; os lançamentos com um número de versão menor ímpar correspondiam a versões de desenvolvimento. O terceiro componente do número de versão correspondia a correções (releases) da versão. A partir da versão 2.6, Torvalds alterou esse padrão, criando um quarto dígito. Assim, a árvore estável e a de desenvolvimento confundem-se. Atualmente, considera-se uma versão tanto mais estável quanto maior o quarto dígito. Enquanto que Torvalds continua a lançar as versões de desenvolvimento mais recentes, a manutenção das versões "estáveis" mais antigas é delegada a outros, incluindo David Weinehal (2.0), Alan Cox e mais tarde Marc-Christian Petersen (2.2), Marcelo Tosatti e depois Willy Tarreau (2.4) e o próprio Torvalds, Andrew Morton e Adrian Bunk (2.6). Para além dos núcleos "oficiais", "árvores" alternativas podem ser obtidas de outras fontes. Distribuidores de sistemas operativos completos mantêm as suas próprias versões do Linux, onde, por exemplo, incluem controladores de dispositivos que não se encontram incluídos na versão oficial.
O mascote do Linux (núcleo e tudo que é relacionado) é um pinguim chamado Tux, criado por Larry Ewing. O motivo pelo qual a mascote é um pinguim é, como Torvalds disse, "O Linus gosta de pinguins. É isso." O nome Tux foi sugerido para representar Torvalds' Unix, e assim ficou.